/*
solveXYZ2.m

<description>

Authors
    Adela Gherga <adelagherga@gmail.com>
Created
    18 November 2022
*/

solTest:=function(u,y1,y2)
    X:=u^2;
    Y:=y1*y2;
    Z:=Integers()!((y1+y2)/2);
    if (X+Y eq Z^2) and (X ge Y) and (Z gt 0) then
	return {[X,Y,Z]};
    end if;
    return {};
end function;




convertToXYZ2:=function(xyzsols)
    /*
      <description>

      Parameters
          <param>: <param type>
	      <param description>
      Returns
          <param>: <param type>
	      <param description>
   */

    sols:={};
    for s in xyzsols do
	a,b,c:=Explode(s);
	if IsEven(a) then
	    sols:=sols join solTest(Integers()!(a/2),b,c);
	    sols:=sols join solTest(b,2*c,2*a);
	    sols:=sols join solTest(c,2*a,-2*b);
	elif IsEven(b) then
            sols:=sols join solTest(a,2*b,2*c);
	    sols:=sols join solTest(Integers()!(b/2),c,a);
	    sols:=sols join solTest(c,2*a,-2*b);
	else
	    assert IsEven(c);
            sols:=sols join solTest(a,2*b,2*c);
	    sols:=sols join solTest(b,2*c,2*a);
	    sols:=sols join solTest(Integers()!(c/2),a,-b);
	end if;
    end for;
    return sols;
end function;


time xyzsols:=solveXYZ(primelist);
sols:=convertToXYZ2(xyzsols);

Sort(~primelist);
assert 2 in primelist;
s:=#primelist;
assert s ge 2;
C:=CartesianProduct([[0,1] : i in [1..s]]);
DList:=Sort([&*[primelist[i]^c[i] : i in [1..s]] : c in C]);
// Generate all possible values for D.
time xyzsols:=solveXYZ(primelist);
sols:=convertToXYZ2(xyzsols);
Exclude(~DList,1);
// Determine all solutions corresponding to D=1.

for D in DList do
    K<sqrtD>:=QuadraticField(D);
    OK:=RingOfIntegers(K);
    b0, SplitPrimes, NonSplitPrimes:= DecompositionOfPrimesXYZ2(S,D);
    if IsEmpty(SplitPrimes) then
        A0:= AlphasXYZ2([],b0,SplitPrimes,NonSplitPrimes,S,D);  // generates all alphas in the case I, I_ == []





idealEquations:=function(primelist,D)
    assert &and[IsPrime(p) : p in primelist];
    K<sqrtD>:=QuadraticField(D);
    OK:=MaximalOrder(K);
    sqrtD:=OK!sqrtD;

    chiList:=[* [* 1*OK, [] *] *];
    for p in primelist do
	facts:=Factorisation(p*OK);
	facts:=[fact[1] : fact in facts]; // The prime ideals above p.
	if IsInert(p,OK) then
	    if p eq 2 then
		Lp:={1*OK,facts[1]};
		Mp:={};
	    else
		Lp:={1*OK};
		Mp:={};
	    end if;
	elif IsRamified(p,OK) then
	    Lp:={1*OK,facts[1]};
	    Mp:={};
	else
	    if p eq 2 then
		Lp:={1*OK};
		Mp:={<facts[2],facts[1]>};
	    else
		Lp:={1*OK};
		Mp:={<1*OK,facts[1]>};
	    end if;
	end if;
	chiListNew1:=[* [* pr[1]*fb,pr[2] *] : fb in Lp,pr in chiList *];
	chiListNew2:=[* [* pr[1]*qr[1],pr[2] cat [qr[2]] *]
		      : qr in Mp, pr in chiList *];
	chiList:=chiListNew1 cat chiListNew2;
    end for;
    return chiList;
end function;

principalize:=function(fa,S)
    /*
      From the pair (fa,S), where S = (fp_1,...,fp_r) and
      (a_0 X - theta Y)OK = fa fp_1^{n_1} ... fp_s^{n_s} is an equation of
      ideals in K, determine delta_1,...,delta_r and all possible tau such that
      a_0 X - Y theta = tau \delta_1^{b_1} ... \delta_r^{b_r} is an equation
      in K (as in equation (15)).
      If the class [fa] is not contained in the subgroup of the class group
      generated by [fp_1,...,fp_r] then then is is impossible; the function
      returns false,[],[].

      Parameters
          fa: RngOrdIdl
              An ideal of OK.
          S: SeqEnum
              A list of prime ideals fp_1,...,fp_s of K.
      Returns
          tf: BoolElt
              A true/false value. If the class [fa] is not contained in the
	      subgroup of the class group generated by [fp_1,...,fp_r] then
	      then is is impossible; return false, otherwise return true.
          tauList: SeqEnum
              The set of possibilities for tau in K. This is equal to 1/2 of the
              number of roots of unity in K (since we can absorb \pm 1
	      in (X,Y)).
          deltaList: SeqEnum
              A list of elements delta_1,...,delta_r in K which form the basis
              for the S-unit group OS^* modulo roots of unity.
   */
    K:=NumberField(Parent(Basis(fa)[1]));
    OK:=MaximalOrder(K);
    s:=#S;
    Zs:=FreeAbelianGroup(s);
    ClK,eta:=ClassGroup(K);
    // Given an ideal fa, we obtain its class in ClK by fa@@eta.
    phi:=hom<Zs -> ClK | [ClK | fp@@eta : fp in S ]>;
    img:=Image(phi);
    if -fa@@eta in img eq false then
	return false,[K | ],[K | ];
    end if;
    if s eq 0 then
	fa2:=fa;
    else
	rr:=(-fa@@eta)@@phi;
	rr:=Eltseq(Zs!rr);
	fa2:=fa*&*[S[i]^rr[i] : i in [1..s]];
    end if;
    tf,alpha:=IsPrincipal(fa2);
    assert tf; // The ideal really is principal, and equal to alpha.
    if #S eq 0 then
	U,mu:=UnitGroup(K);
    else
	U,mu:=SUnitGroup(S);
    end if;
    deltaList:=[K!(mu(u)) : u in OrderedGenerators(U)];
    rtun:=deltaList[1];
    assert IsRootOfUnity(rtun);
    deltaList:=deltaList[2..#deltaList];

    // Reorder deltaList so that the units apear first.
    deltaList:=[delta : delta in deltaList | Abs(Norm(delta)) eq 1] cat
	       [delta : delta in deltaList | Abs(Norm(delta)) ne 1];
    r:=Order(U.1) div 2;
    assert rtun^r eq OK!(-1);
    tauList:=[alpha*rtun^i : i in [0..(r-1)]];
    return true,tauList,deltaList;
end function;

// from here plug into principalize function without too many changes, but also,
// it is unclear what is happening at p=2 when 2 splits. For example, if

equationsInK:=function(primelist,D)
    chiList:=idealEquations(primelist,D);
    alphaDeltaList:=[* *];
    for pr in chiList do
	af:=pr[1];
	fplist:=pr[2];
	tf,alphaList,deltaList:=principalize(af,fplist);
	if tf then
	    for alpha in alphaList do
		alphaDeltaList:=alphaDeltaList cat [* [* alpha,deltaList *] *];
	    end for;
	end if;
    end for;
    ranks:=[#pr[2] : pr in alphaDeltaList];
    // Sort the elements in order of rank for SmallSieveInfo.
    Sort(~ranks,~permut);
    return [* alphaDeltaList[i^permut] : i in [1..#alphaDeltaList] *];
end function;


heightBoundChi:=function(primelist)
    /*
      Determine the height bound max(h(X),h(Y)) on X and Y which satisfy
      a_0 X^d + ... + a_d Y^d = a p_1^{z_1} ... p_v^{z_v}, as per von Kanel and
      Matshke, and return 2*max(h(X),h(Y))+Log(2)+Log(a0).

      Parameters
          alist: SeqEnum
              A list of coefficients a_0, a_1,...,a_d.
          a: RngIntElt
          primelist: SeqEnum
              A list of rational primes p_1, p_2,...,p_v.
      Returns
          maxhXY: FldReElt
	      The value 2*max(h(X),h(Y))+Log(2)+Log(a0), where max(h(X),h(Y)) is
	      the height bound of von Kanel and Matshke.
   */
    assert &and[IsPrime(p) : p in primelist];
    assert 2 in primelist;
    DS:=(1728)*(&*primelist)^2;
    primesDS:=PrimeDivisors(DS);
    s0:=&*[1-1/p^2 : p in primesDS];
    vInf:=&*[(p-1)*p^(Floor(Valuation(DS,p)/2-1)) : p in primesDS];
    d:=DS*(&*[1+1/p : p in primesDS]);
    l:=(DS/6)*(&*[p+1 : p in primesDS]);
    lStar:=d/6;

    g:=1+d/12;
    // Upper bound for the genus of the corresponding modular curve.
    m:=s0*DS/12-vInf/2;
    // Upper bound for the number of newforms of level dividing N.
    betaBar:=(m/2)*Log(m)+(5/8)*m*(18+Log(l));
    betaBarStar:=(g/2)*Log(g*lStar)+(lStar/2)*Log(4+4*Log(lStar));
    alphaBar:=Min([betaBar,betaBarStar]);
    kappa:=4*Pi(RealField())+Log(163/Pi(RealField()));
    omegaPrime:=4*alphaBar+2*Log(alphaBar+kappa)+35+4*kappa;
    // The term Omega_opt - h(D)/3.

    maxChiPrime:=3*omegaPrime+Log(2)+8*Log(&*[p : p in primelist]);
    // The bound on chi - 3h(D)/2.
    return maxChiPrime;
end function;

heightBound
for D in DList do
    print "D:",D;
    time tauDeltaList:=equationsInK(primelist,D);
    K:=Universe([pr[1] : pr in tauDeltaList]
		cat &cat[pr[2] : pr in tauDeltaList]);
    K:=NumberField(K);
    sqrtD:=K.1;
    OK:=MaximalOrder(K);

    eqncount:=0;
    printf "++++++++++++++++++++++++++++++++++\n";
    for pr in tauDeltaList do
	eqncount:=eqncount+1;
	printf "Working on equation number %o...\n",eqncount;
	tau:=pr[1];
	deltaList:=pr[2];
	S:=&join[Support(delta*OK) : delta in deltaList];

	IU:=primelist;
	for fp in S do
	    p:=Characteristic(ResidueClassField(fp));
	    Exclude(~IU,p);
	    // assert that these then show up in X' as well?
	end for;
	for p in PrimeDivisors(Norm(tau*OK)) do
	    Exclude(~IU,p);
	    // assert that these then show up in X' as well?
	end for;
	print "IU:", IU;
	print tau;
	print S;
	print "-----";
    end for;
end for;
